name: Continuous Integration & Deployment

on:
  push:
    branches:
      - "main"
      - "dev"
      - "test"
    paths-ignore:
      - "**.md"
      - ".github/**"

jobs:
  pre-build:
    runs-on: ubuntu-latest
    steps:
      - name: "setup:checkout-code"
        uses: actions/checkout@v4
      
      - name: "test:unit-test"
        run: |
          # This is an example how we can run tests before build
          echo "Running unit-tests..."
          echo "Unit-tests finished"
      
      - name: "security:snyk-scan"
        run: |
          # This is an example how we can run security scan before build
          echo "Running security scan..."
          echo "Security scan finished"
  build:
    runs-on: ubuntu-latest
    needs: [pre-build]
    outputs:
      task_definition: ${{ steps.task-definition.outputs.task_definition }}
    permissions:
      contents: read
      id-token: write  # Required for OIDC authentication if used

    steps:
      - name: "setup:checkout-code"
        uses: actions/checkout@v4

      - name: "setup:set-environment"
        id: set-environment
        run: |
          if [[ "${GITHUB_REF_NAME}" == "main" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=dev" >> $GITHUB_ENV
          fi

      - name: "setup:configure-aws-credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT }}:role/GitHubActionsAWSRole
          aws-region: ${{ secrets.AWS_REGION }}

      - name: "setup:login-ecr"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: "build:build-and-push"
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          GIT_REPOSITORY=$(echo "${{ github.repository }}" | cut -d'/' -f2)

          echo "GIT_REPOSITORY=$GIT_REPOSITORY" >> $GITHUB_ENV

          ECR_REPOSITORY="$ENVIRONMENT-$GIT_REPOSITORY" >> $GITHUB_ENV

          IMAGE_TAG="${{ github.ref_name }}-${COMMIT_SHA::7}"
          IMAGE_TAG_LATEST="latest"

          echo "Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .

          echo "Tagging image as latest..."
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG_LATEST

          echo "Pushing images to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG_LATEST

      - name: build:register-ecs-task-definition
        id: task-definition
        run: |
          IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:latest"
          
          aws ecs describe-task-definition \
            --task-definition $GIT_REPOSITORY-$ENVIRONMENT-task-definition \
            --region $AWS_REGION \
            --query 'taskDefinition' \
            --output json \
          | jq '{
              family,
              networkMode,
              containerDefinitions,
              volumes,
              taskRoleArn,
              executionRoleArn,
              requiresCompatibilities,
              cpu,
              memory
            }' > ecs-task-def-updated.json

          sed -i "s|<IMAGE>|$IMAGE|g" ecs-task-def-updated.json

          TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://ecs-task-def-updated.json | jq -r '.taskDefinition.taskDefinitionArn')
          echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_ENV

          echo "task_definition=$(basename "$TASK_DEF_ARN")" >> $GITHUB_OUTPUT
      
      - name: "buid:generate-appssec.json"
        run: |
          cat > appspec.json <<EOF
          {
            "version": "0.0",
            "Resources": [
              {
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": "$TASK_DEF_ARN",
                    "LoadBalancerInfo": {
                      "ContainerName": "app",
                      "ContainerPort": 8080
                    }
                  }
                }
              }
            ]
          }
          EOF

          # Validate JSON
          jq . appspec.json > /dev/null

      - name: 'artifact:appspec:upload'
        uses: actions/upload-artifact@v5
        with:
          name: appspec
          path: appspec.json
          overwrite: true
  pre-deploy:
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: "setup:checkout-code"
        uses: actions/checkout@v4
      
      - name: "pre-deploy:prepare-something"
        run: |
          echo "Running pre-deploy..."
          echo "Pre-deploy finished"  
          
  deploy:
    runs-on: ubuntu-latest
    needs: [build, pre-deploy]
    permissions:
      contents: read
      id-token: write  # Required for OIDC authentication if used

    steps:
      - name: "setup:checkout-code"
        uses: actions/checkout@v4

      - name: "setup:configure-aws-credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT }}:role/GitHubActionsAWSRole
          aws-region: ${{ secrets.AWS_REGION }}

      - name: 'artifact:appspec:download'
        uses: actions/download-artifact@v5
        with:
          name: appspec
      
      - name: "setup:set-environment"
        id: set-environment
        run: |
          if [[ "${GITHUB_REF_NAME}" == "main" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=dev" >> $GITHUB_ENV
          fi

      - name: "setup:set-deployment-strategy"
        id: set-strategy
        run: |
          if [[ "${GITHUB_REF_NAME}" == "main" ]]; then
            echo "DEPLOYMENT_STRATEGY=canary" >> $GITHUB_ENV
          else
            echo "DEPLOYMENT_STRATEGY=rolling" >> $GITHUB_ENV
          fi

      - name: "deploy:deploy-ecs-service"
        run: |
          GIT_REPOSITORY=$(echo "${{ github.repository }}" | cut -d'/' -f2)

          CLUSTER_NAME="$ENVIRONMENT-ecs-cluster"
          SERVICE_NAME="$GIT_REPOSITORY-$ENVIRONMENT-service"
          TASK_DEF_ARN="arn:aws:ecs:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT }}:task-definition/${{ needs.build.outputs.task_definition }}"

          ls -la

          if [[ "$DEPLOYMENT_STRATEGY" == "canary" ]]; then
            echo "Triggering CodeDeploy ECS canary deployment..."

            APPSPEC_CONTENT=$(jq -c . appspec.json | sed 's/"/\\"/g')
            cat > revision.json <<EOF
          {
            "revisionType": "AppSpecContent",
            "appSpecContent": {
              "content": "$APPSPEC_CONTENT"
            }
          }
          EOF

            DEPLOYMENT_ID=$(aws deploy create-deployment \
              --application-name "$GIT_REPOSITORY-$ENVIRONMENT-codedeploy" \
              --deployment-group-name "$GIT_REPOSITORY-$ENVIRONMENT-canary" \
              --deployment-config-name "CodeDeployDefault.ECSCanary10Percent5Minutes" \
              --description "Canary deployment triggered by GHA" \
              --revision file://revision.json \
              | jq -r '.deploymentId')

            echo "Deployment started: $DEPLOYMENT_ID"
            #echo "Waiting for deployment to complete..."

            # Poll until the deployment succeeds or fails
            #while true; do
            #  STATUS=$(aws deploy get-deployment --deployment-id $DEPLOYMENT_ID \
            #          | jq -r '.deploymentInfo.status')
              
            #  echo "Current status: $STATUS"

            #  if [[ "$STATUS" == "Succeeded" ]]; then
            #    echo "Deployment succeeded!"
            #    break
            #  elif [[ "$STATUS" == "Failed" ]] || [[ "$STATUS" == "Stopped" ]]; then
            #    echo "Deployment failed or stopped!"
            #    exit 1
            #  else
            #    sleep 15
            #  fi
            #done

            #echo "CodeDeploy canary deployment triggered successfully."

          else
            echo "Performing standard ECS rolling update..."

            # Update ECS service with new task definition (rolling update)
            aws ecs update-service \
              --cluster $CLUSTER_NAME \
              --service $SERVICE_NAME \
              --task-definition $TASK_DEF_ARN \
              --force-new-deployment \
              --region $AWS_REGION

            # Wait until service stabilizes
            aws ecs wait services-stable \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_NAME \
              --region $AWS_REGION
          fi